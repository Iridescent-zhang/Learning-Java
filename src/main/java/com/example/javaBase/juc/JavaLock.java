package com.example.javaBase.juc;

/**
 * Created with IntelliJ IDEA.
 *
 * @author : lczhang
 * @version : 1.0
 * @Project : Learning-Project
 * @Package : com.example.interview.javaBase.juc
 * @ClassName : .java
 * @createTime : 2025/3/11 21:39
 * @Email : lczhang93@gmail.com
 * @Website : https://iridescent-zhang.github.io
 * @Description :
 */

import java.lang.reflect.Field;

/**
 * 阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。
 *
 * 在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。
 * key 如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。
 * key 是多核 CPU 才回去考虑自旋，不然就是搞笑了。前提是能由多个 并行 执行任务的线程才回去考虑自旋
 *
 * 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
 * 这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。
 * 首先为什么Synchronized能实现线程同步？
 * 在回答这个问题之前我们需要了解两个重要的概念：key “Java对象头”、“Monitor”。
 *
 * key Java对象头
 * synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，key 这把锁就是存在Java对象头里的，而Java对象头又是什么呢？
 * 我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。
 * Mark Word：
 *      默认存储对象的 HashCode，分代年龄（GC年龄）和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。
 *      key 它会根据对象的状态(锁标志位的变化)复用自己的存储空间，也就是说在运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化。
 * Klass Point：指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
 *
 * key Monitor
 * Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象都有一把看不见的锁，称为内部锁或者 Monitor 锁。key 【就把它叫监视器对象吧，他就是 Java 的内部锁】
 *      Monitor是线程私有的数据结构，每一个线程都有一个可用 Monitor Record 列表，同时还有一个全局的可用列表。
 *      每一个被锁住的对象都会和一个 Monitor 关联，同时 key Monitor中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。
 * key synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。
 * 如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。
 * 这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。
 * 这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。
 *
 * 所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。下面我们给出四种锁状态对应的的Mark Word内容:
 锁状态	存储内容	                                            存储内容
 无锁	对象的hashCode、对象分代年龄、是否是偏向锁（0）	            01
 偏向锁	偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）   	    01
 轻量级锁	指向栈中锁记录的指针	                                00
 重量级锁	指向互斥量（重量级锁）的指针	                        10
 *
 * 无锁：无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 key 其实就是 CAS，应该是 CAS 尝试去改值，不是说 CAS 去拿锁
 * 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。
 *
 * 偏向锁：偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
 * 在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。
 * 当一个线程访问同步代码块并获取锁时，会在该锁的 Mark Word 里存储锁偏向的线程ID。key 此后在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
 * 引入偏向锁是为了在无多线程竞争的情况下 key 尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在第一次置换 ThreadID 的时候依赖一次 CAS 原子指令即可。
 * key 讲的好清楚呀
 * key 在偏向锁模式下，线程在执行完同步代码块后，锁仍然保持偏向状态，不会主动恢复到无锁状态。只有在其他线程尝试获取锁时，JVM 才会撤销偏向锁，将其升级为轻量级锁或重量级锁。
 * 偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程(以确保锁的状态可以安全地修改)，判断锁对象是否处于被锁定状态（即是否仍然被偏向线程持有）。
 * 撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。
 *
 * 轻量级锁：
 * 是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能（相比重量级锁）。
 * 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），
 *    虚拟机首先将 key 在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间(用于存储锁对象目前的 Mark Word 的拷贝)，然后拷贝对象头中的Mark Word复制到锁记录中（这不是废话吗）。
 * 拷贝成功后，虚拟机 key 将使用 CAS 操作尝试将锁对象的 Mark Word 更新为指向 Lock Record 的指针，并将Lock Record里的 owner 指针指向对象的Mark Word。
 * 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。
 * 如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。
 * 若当前 key 只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。
 * key【感觉就像 Mark Word 是用来指向一个栈帧(或者说指向一个锁/锁记录)的，这个锁是哪个线程的就说明当前锁被哪个线程持有】
 *
 * 重量级锁
 * 升级为重量级锁时，锁标志的状态值变为“10”，此时 key Mark Word 中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。
 *
 * 综上，偏向锁通过对比Mark Word解决加锁问题，避免执行轻量锁的CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。
 *
 * ------------
 * 公平锁 VS 非公平锁
 * 公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低。
 * 非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁。
 * 非公平锁的优点是 key 可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。
 *
 * 可重入锁 VS 非可重入锁
 * 可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（key 前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
 * Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。
 */
public class JavaLock {
    private static Integer test = 10;
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Class<JavaLock> javaLockClass = JavaLock.class;
        Field field = javaLockClass.getDeclaredField("test");
        field.setAccessible(true);
        /**
         * 对于非静态字段，field.get 需要传入一个对象实例，因为字段属于对象。
         * 对于静态字段，field.get 需要传入 null，因为字段属于类而不是对象。
         */
        Integer o = (Integer)field.get(null);
        System.out.println("o = " + o);
    }
}
