package com.example.javaBase.gc;

/**
 * Created with IntelliJ IDEA.
 *
 * @author : lczhang
 * @version : 1.0
 * @Project : Learning-Project
 * @Package : com.example.javaBase.gc
 * @ClassName : .java
 * @createTime : 2025/3/16 12:50
 * @Email : lczhang93@gmail.com
 * @Website : https://iridescent-zhang.github.io
 * @Description :
 */

/**
 * 分配对象
 * Java 中对象地址操作主要使用 key Unsafe 调用了 C 的 allocate 和 free 两个方法，分配方法有两种：
 * 空闲链表（free list）： 通过额外的存储记录空闲的地址，将随机 IO 变为顺序 IO，但带来了额外的空间消耗。
 * 碰撞指针（bump pointer）： 通过一个指针作为分界点，需要分配内存时，仅需把指针往空闲的一端移动与对象大小相等的距离【估计在没有内存碎片情况下好用】，分配效率较高，但使用场景有限。
 * 如果能保证内存没碎片，分配就可以用 pointer bumping 方式，只需要挪一个指针就完成了分配，非常快。而如果内存有碎片就得用 freelist 之类的方式管理，分配速度通常会慢一些。
 *
 * 识别垃圾
 * 引用计数法（Reference Counting）： 对每个对象的引用进行计数，每当有一个地方引用它时计数器 +1、引用失效则 -1，引用的计数放到对象头中，大于 0 的对象被认为是存活对象。
 *      虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。
 * 可达性分析，又称引用链法（Tracing GC）： 从 GC Root 开始进行对象搜索，可以被搜索到的对象即为可达对象，此时还不足以判断对象是否存活/死亡，需要经过多次标记才能更加准确地确定，
 *      key 整个连通图之外的对象便可以作为垃圾被回收掉。目前 Java 中主流的虚拟机均采用此算法。
 * 备注：key 引用计数法是可以处理循环引用问题的，下次面试时不要再这么说啦~ ~  笑死了
 *
 * 收集算法：
 * Mark-Sweep（标记-清除）： 回收过程主要分为两个阶段，第一阶段为追踪（Tracing）阶段，即从 GC Root 开始遍历对象图，并标记（Mark）所遇到的每个对象（key 标记存活的），
 *   第二阶段为清除（Sweep）阶段，即回收器检查堆中每一个对象，并将所有未被标记的对象进行回收，整个过程不会发生对象移动。
 *   整个算法在不同的实现中会使用 key 三色抽象（Tricolour Abstraction）、位图标记（BitMap）等技术来提高算法的效率，存活对象较多时较高效。
 * Mark-Compact （标记-整理）： 这个算法的主要目的就是解决在非移动式回收器中都会存在的碎片化问题，也分为两个阶段，第一阶段与 Mark-Sweep 类似，（key 标记存活的），
 *   第二阶段则会 key 对存活对象按照整理顺序（Compaction Order）进行整理。主要实现有双指针（Two-Finger）回收算法【这个好记】
 *   、滑动回收（Lisp2）算法和引线整理（Threaded Compaction）算法等。
 * Copying（复制）： key 将空间分为两个大小相同的 From 和 To 两个半区，同一时间分配内存只会使用其中一个，每次进行回收时将一个半区的存活对象通过复制的方式转移到另一个半区。
 *   复制算法可以通过碰撞指针的方式进行快速地分配内存，但是也存在着空间利用率不高的缺点，另外就是存活对象比较大时复制的成本比较高。
 * 标记整理和复制：
 *   虽然 compaction 与 copying 都涉及移动对象，但取决于具体算法，compaction 可能要先计算一次对象的目标地址，然后修正指针，最后再移动对象。copying 则可以把这几件事情合为一体来做，所以可以快一些。
 *
 * 收集器：
 * 目前在 Hotspot VM 中主要有分代收集和分区收集两大类，具体可以看下面的这个图，不过未来会逐渐向分区收集发展。
 * 分代：
 *   ParNew： 一款多线程的收集器，采用复制算法，主要工作在 Young 区，可以通过 -XX:ParallelGCThreads 参数来控制收集的线程数，整个过程都是 STW 的，常与 CMS 组合使用。
 *   CMS： 以获取最短回收停顿时间为目标，采用“标记-清除”算法，分 4 大步进行垃圾收集【标记三步清除一步？中间那步是从初始标记点并发去标记】，
 *          其中初始标记和重新标记【在并发标记阶段变化的还要再标一下】会 STW ，多数应用于互联网站或者 B/S 系统的服务器端上，JDK9 被标记弃用，JDK14 被删除
 * 分区：
 * G1： 一种服务器端的垃圾收集器，key 应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能地满足垃圾收集暂停时间的要求。
 * ZGC： JDK11 中推出的一款低延迟垃圾回收器，适用于大内存低延迟服务的内存管理和回收，SPECjbb 2015 基准测试，在 128G 的大堆下，最大停顿时间才 1.68 ms，停顿时间远胜于 G1 和 CMS。
 * Shenandoah： 由 Red Hat 的一个团队负责开发，与 G1 类似，基于 Region 设计的垃圾收集器，但不需要 Remember Set 或者 Card Table 来记录跨 Region 引用，停顿时间和堆的大小没有任何关系。停顿时间与 ZGC 接近。
 *
 * 常用工具;
 * 命令行终端
 * 标准终端类：jps、jinfo、jstat、jstack、jmap
 * 功能整合类：jcmd、vjtools、arthas、greys
 * 可视化界面
 * 简易：JConsole、JVisualvm、HA、GCHisto、GCViewer
 * 进阶：MAT、JProfiler
 *
 * 命令行推荐 arthas ，可视化界面推荐 JProfiler，此外还有一些在线的平台 gceasy
 *
 * 在做 GC 问题排查和优化之前，我们需要先来明确下到底是不是 GC 直接导致的问题，或者应用代码导致的 GC 异常，最终出现问题。
 * 评判 GC 的两个核心指标：
 * 延迟（Latency）： 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的 key 最长时间，越短越好，一定程度上可以接受频次的增大，GC 技术的主要发展方向。
 * 吞吐量（Throughput）： 应用系统的生命周期内，由于 GC 线程会占用 Mutator(应用程序) 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，
 *      例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。
 * key 目前各大互联网公司的系统基本都更追求低延时，避免一次 GC 停顿的时间过长对用户体验造成损失，衡量指标需要结合一下应用服务的 SLA，主要如下两点来判断：
 * 简而言之，即为一次停顿的时间不超过应用服务的 TP9999【应用4个9耗时】，GC 的吞吐量不小于 99.99%。
 *
 * ------------
 * ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：
 * 停顿时间不超过10ms；
 * 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
 * 支持8MB~4TB级别的堆（未来支持16TB）。
 *
 * 从设计目标来看，我们知道ZGC适用于 key 大内存低延迟服务的内存管理和回收。
 *
 * 很多低延迟高可用 Java 服务的系统可用性经常受GC停顿的困扰。GC停顿指垃圾回收期间STW（Stop The World），当STW时，所有应用线程停止活动，等待GC停顿结束。
 * 以美团风控服务为例，部分上游业务要求风控服务65ms内返回结果，并且可用性要达到99.99%。但因为GC停顿，我们未能达到上述可用性目标。
 *
 * 在介绍ZGC之前，首先回顾一下CMS和G1的GC过程以及停顿时间的瓶颈。CMS新生代（用的是ParNew）的Young GC、G1和ZGC都基于标记-复制算法，但算法具体实现的不同就导致了巨大的性能差异。
 * key 标记-复制算法应用在 CMS 新生代（ParNew 是 CMS 默认的新生代垃圾回收器）和 G1 垃圾回收器中。标记-复制算法可以分为三个阶段：
 * 1、标记阶段，即从GC Roots集合开始，标记活跃对象；
 * 2、转移阶段，即把活跃对象复制到新的内存地址上；
 * 3、重定位阶段，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。
 *
 * key 怎么和小林一模一样
 * G1的混合回收过程可以分为标记阶段、清理阶段和复制阶段。
 *
 * 1、标记阶段停顿分析  【 这三步和 CMS 的是类似的】
 * 初始标记阶段：初始标记阶段是指从GC Roots出发标记全部直接子节点的过程，该阶段是STW的。由于GC Roots数量不多，通常该阶段耗时非常短。
 * 并发标记阶段：并发标记阶段是指从GC Roots开始对堆中对象进行可达性分析，找出存活对象。该阶段是并发的，即应用线程和GC线程可以同时活动。并发标记耗时相对长很多，但因为不是STW，所以我们不太关心该阶段耗时的长短。
 * 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的。
 *
 * 2、清理阶段停顿分析
 * 清理阶段 清点 出有存活对象的分区(Region)和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的。
 *
 * 3、转移阶段停顿分析
 * 需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。
 *
 * G1 的瓶颈：
 * 转移阶段要处理所有存活的对象，耗时会较长。因此，G1停顿时间的瓶颈主要是标记-复制中的转移阶段STW。
 * key 为什么G1转移阶段不能和标记阶段一样并发执行呢？主要是 G1 未能解决转移过程中准确定位对象地址的问题。【标记-复制算法的第三阶段：重定位对象指针】【这句话真的很关键】
 * 也就是说 G1 表面上看起来多了一个清点分区的步骤，实际上估计是在转移阶段融合和重定位步骤
 *
 * 与CMS中的ParNew和G1类似，key ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在 标记、转移和重定位阶段 几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。
 * ZGC只有三个STW阶段：初始标记，再标记，key [初始转移]。【不同点在这】
 * 其中，初始标记和初始转移 分别都只需要扫描所有 GC Roots，其处理时间和 GC Roots的数量成正比，一般情况耗时非常短；再标记阶段STW时间很短，最多1ms，超过1ms则再次进入并发标记阶段。
 * key 即，ZGC几乎所有暂停都只和 GC Roots 集合大小相关，停顿时间不会随着堆的大小或者活跃对象的大小而增加。
 * 与ZGC对比，G1的转移阶段完全STW的，且停顿时间随存活对象的大小增加而增加。【因为 G1 做不到转移时准确定位对象地址的问题】
 *
 * ZGC关键技术:【一定要会，这将是你的亮点】
 * key ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。
 * 大致原理描述如下：并发转移中 "并发" 意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。
 * 而在ZGC中，应用线程访问对象将触发 "读屏障"，如果发现对象被移动过，那么 "读屏障" 会把读出来的指针更新到对象的新地址上，保证应用线程始终访问的都是对象的新地址。
 * 那么，JVM是如何判断对象被移动过呢？就是利用对象引用的地址，即 key 着色指针。
 *
 * key 着色指针是一种将信息存储在指针中的技术。
 * key 读屏障是 JVM 向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。需要注意的是，仅 "从堆中读取对象引用" 才会触发这段代码。
 * ZGC中读屏障的代码作用：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。
 *
 * ZGC仅支持64位系统，它把64位虚拟地址空间划分为多个子空间,[0~4TB) 对应Java堆，[4TB ~ 8TB) 称为M0地址空间，[8TB ~ 12TB) 称为M1地址空间，[12TB ~ 16TB) 预留未使用，[16TB ~ 20TB) 称为Remapped空间。
 * 与上述地址空间划分相对应，ZGC实际仅使用64位地址空间的第0~41位，而第42~45位存储元数据，第47~63位固定为0。
 * ZGC将对象存活信息存储在42~45位中，这与传统的垃圾回收并将对象存活信息放在对象头中完全不同。
 *
 * 三色标记法的基本概念
 * 三色标记法将堆中的对象分为三种颜色：
 * 白色：表示对象尚未被标记，可能是垃圾。
 * 灰色：表示对象已经被标记，但其子对象还未被标记。
 * 黑色：表示对象及其子对象都已被标记，是存活对象。
 * 1) 初始标记阶段（Initial Marking）
 * 目标：从 GC Roots（如栈帧、静态变量等）出发，标记所有直接引用的对象。
 * 特点：该阶段是 STW（Stop-The-World） 的，即暂停所有应用线程。
 * GC Roots 直接引用的对象从 白色 变为 灰色。
 * 其他对象保持 白色。
 * 2) 并发标记阶段（Concurrent Marking）
 * 目标：从灰色对象出发，递归标记所有可达对象。
 * 特点：该阶段是 并发 的，即应用线程和 GC 线程可以同时运行。
 * 灰色对象被标记为 黑色。
 * 灰色对象的子对象从 白色 变为 灰色。
 * 3) 再标记阶段（Remarking）
 * 目标：重新标记那些在并发标记阶段发生变化的对象（例如，应用线程修改了引用关系）。
 * 特点：该阶段是 STW 的，但通常比初始标记阶段耗时稍长。
 * 重新标记的对象从 白色 变为 灰色 或 黑色。
 */
public class CMS {
}
